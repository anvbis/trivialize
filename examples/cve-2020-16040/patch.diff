diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index b1505f0a5f..c95a9ac707 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1660,12 +1660,13 @@ class RepresentationSelector {
     // signed overflow. This is incompatible with relying on a Word32 truncation
     // in order to skip the overflow check.  Similarly, we must not drop -0 from
     // the result type unless we deopt for -0 inputs.
-    Type const restriction =
-        truncation.IsUsedAsWord32()
-            ? Type::Any()
-            : (truncation.identify_zeros() == kIdentifyZeros)
-                  ? Type::Signed32OrMinusZero()
-                  : Type::Signed32();
+  
+    // Type const restriction =
+    //     truncation.IsUsedAsWord32()
+    //         ? Type::Any()
+    //         : (truncation.identify_zeros() == kIdentifyZeros)
+    //               ? Type::Signed32OrMinusZero()
+    //               : Type::Signed32();
 
     // Handle the case when no int32 checks on inputs are necessary (but
     // an overflow check is needed on the output). Note that we do not
@@ -1680,7 +1681,7 @@ class RepresentationSelector {
         right_upper.Is(Type::Signed32OrMinusZero()) &&
         (left_upper.Is(Type::Signed32()) || right_upper.Is(Type::Signed32()))) {
       VisitBinop<T>(node, UseInfo::TruncatingWord32(),
-                    MachineRepresentation::kWord32, restriction);
+                    MachineRepresentation::kWord32, Type::Signed32());
     } else {
       // If the output's truncation is identify-zeros, we can pass it
       // along. Moreover, if the operation is addition and we know the
@@ -1699,7 +1700,7 @@ class RepresentationSelector {
       // potentially guarded by a check.
       UseInfo right_use = CheckedUseInfoAsWord32FromHint(hint, kIdentifyZeros);
       VisitBinop<T>(node, left_use, right_use, MachineRepresentation::kWord32,
-                    restriction);
+                    Type::Signed32());
     }
 
     if (lower<T>()) {
